// Code generated by thriftgo (0.3.18). DO NOT EDIT.

package score

import (
	"context"
	"github.com/apache/thrift/lib/go/thrift"
)

type ScoreService interface {
}

type ScoreServiceClient struct {
	c thrift.TClient
}

func NewScoreServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ScoreServiceClient {
	return &ScoreServiceClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewScoreServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ScoreServiceClient {
	return &ScoreServiceClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewScoreServiceClient(c thrift.TClient) *ScoreServiceClient {
	return &ScoreServiceClient{
		c: c,
	}
}

func (p *ScoreServiceClient) Client_() thrift.TClient {
	return p.c
}

type ScoreServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ScoreService
}

func (p *ScoreServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ScoreServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ScoreServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewScoreServiceProcessor(handler ScoreService) *ScoreServiceProcessor {
	self := &ScoreServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	return self
}
func (p *ScoreServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush(ctx)
	return false, x
}
