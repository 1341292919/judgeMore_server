// Code generated by thriftgo (0.3.18). DO NOT EDIT.

package appeal

import (
	"context"
	"github.com/apache/thrift/lib/go/thrift"
)

type AppealService interface {
}

type AppealServiceClient struct {
	c thrift.TClient
}

func NewAppealServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *AppealServiceClient {
	return &AppealServiceClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewAppealServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *AppealServiceClient {
	return &AppealServiceClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewAppealServiceClient(c thrift.TClient) *AppealServiceClient {
	return &AppealServiceClient{
		c: c,
	}
}

func (p *AppealServiceClient) Client_() thrift.TClient {
	return p.c
}

type AppealServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      AppealService
}

func (p *AppealServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *AppealServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *AppealServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewAppealServiceProcessor(handler AppealService) *AppealServiceProcessor {
	self := &AppealServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	return self
}
func (p *AppealServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush(ctx)
	return false, x
}
